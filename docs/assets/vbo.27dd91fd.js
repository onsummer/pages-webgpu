const e="[[builtin(position)]] var<out> out_position: vec4<f32>;\n[[location(0)]] var<out> out_color: vec4<f32>;\n[[location(0)]] var<in> in_position_2d: vec2<f32>;\n[[location(1)]] var<in> in_color_rgba: vec4<f32>;\n\n[[stage(vertex)]]\nfn main() -> void {\n  out_position = vec4<f32>(in_position_2d, 0.0, 1.0);\n  out_color = in_color_rgba;\n  return;\n}\n",n="[[location(0)]] var<out> outColor: vec4<f32>;\n[[location(0)]] var<in> in_color: vec4<f32>;\n[[stage(fragment)]]\n\nfn main() -> void {\n  outColor = in_color;\n  return;\n}\n",t=`const canvas = document.getElementById('gpuweb')\nconst vbodata = new Float32Array([\n  -0.5, 0.0, 1.0, 0.0, 0.0, 1.0,\n  0.0, 0.5, 0.0, 1.0, 0.0, 1.0,\n  0.5, 0.0, 0.0, 0.0, 1.0, 1.0\n])\n\nconst vertexShaderSource = \`${e}\`\n\nconst fragmentShaderSource = \`${n}\`\n\nasync function render() {\n  if (!navigator.gpu) {\n    alert('你的浏览器不支持 WebGPU 或未开启 WebGPU 支持')\n    return\n  }\n  const adapter = await navigator.gpu.requestAdapter()\n  const device = await adapter.requestDevice()\n\n  const context = canvas.getContext('gpupresent')\n  const swapChainFormat = "bgra8unorm"\n  const swapChain = context.configureSwapChain({\n    device,\n    format: swapChainFormat\n  })\n\n  const vbo = device.createBuffer({\n    size: vbodata.byteLength,\n    usage: GPUBufferUsage.VERTEX,\n    mappedAtCreation: true\n  })\n  new Float32Array(vbo.getMappedRange()).set(vbodata)\n  vbo.unmap()\n\n  const pipeline = device.createRenderPipeline({\n    vertex: {\n      module: device.createShaderModule({\n        code: vertexShaderSource\n      }),\n      entryPoint: 'main',\n      buffers: [{\n        arrayStride: 6 * vbodata.BYTES_PER_ELEMENT,\n        attributes: [{\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float32x2'\n        }, {\n          shaderLocation: 1,\n          offset: 2 * vbodata.BYTES_PER_ELEMENT,\n          format: 'float32x4'\n        }]\n      }]\n    },\n    fragment: {\n      module: device.createShaderModule({\n        code: fragmentShaderSource\n      }),\n      entryPoint: 'main',\n      targets: [\n        {\n          format: swapChainFormat\n        }\n      ]\n    },\n    primitive: {\n      topology: 'triangle-list',\n    },\n  })\n\n  const commandEncoder = device.createCommandEncoder()\n  const textureView = swapChain.getCurrentTexture().createView()\n  const renderPassDescriptor = {\n    colorAttachments: [\n      {\n        view: textureView,\n        loadValue: {\n          r: 0.0,\n          g: 0.0,\n          b: 0.0,\n          a: 1.0\n        }\n      }\n    ]\n  }\n\n  const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor)\n  passEncoder.setPipeline(pipeline)\n  passEncoder.setVertexBuffer(0, vbo)\n  passEncoder.draw(3, 1, 0, 0)\n  passEncoder.endPass()\n\n  device.queue.submit([commandEncoder.finish()])\n}\n\nrender()\n`,a=new Float32Array([-.5,0,1,0,0,1,0,.5,0,1,0,1,.5,0,0,0,1,1]);async function o(t){const o=await navigator.gpu.requestAdapter(),r=await o.requestDevice(),i="bgra8unorm",c=t.getContext("gpupresent").configureSwapChain({device:r,format:i}),s=r.createBuffer({size:a.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(s.getMappedRange()).set(a),s.unmap();const d=r.createRenderPipeline({vertex:{module:r.createShaderModule({code:e}),entryPoint:"main",buffers:[{arrayStride:6*a.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:2*a.BYTES_PER_ELEMENT,format:"float32x4"}]}]},fragment:{module:r.createShaderModule({code:n}),entryPoint:"main",targets:[{format:i}]},primitive:{topology:"triangle-list"}}),u=r.createCommandEncoder(),f={colorAttachments:[{view:c.getCurrentTexture().createView(),loadValue:{r:0,g:0,b:0,a:1}}]},p=u.beginRenderPass(f);p.setPipeline(d),p.setVertexBuffer(0,s),p.draw(3,1,0,0),p.endPass(),r.queue.submit([u.finish()])}export{o as init,t as javascriptCode};
