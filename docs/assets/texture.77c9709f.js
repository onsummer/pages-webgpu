const e="const canvas = document.getElementById('gpuweb')\nconst vbodata = new Float32Array([\n  -1.0, -1.0, 0.0, 1.0,\n  0.0, 1.0, 0.5, 0.0,\n  1.0, -1.0, 1.0, 1.0\n])\n\nconst vertexShaderSource = `\n`\n\nconst fragmentShaderSource = `\n`\n\nasync function render() {\n  if (!navigator.gpu) {\n    alert('你的浏览器不支持 WebGPU 或未开启 WebGPU 支持')\n    return\n  }\n  const adapter = await navigator.gpu.requestAdapter()\n  const device = await adapter.requestDevice()\n\n  const context = canvas.getContext('gpupresent')\n  const swapChainFormat = 'bgra8unorm'\n  const swapChain = context.configureSwapChain({\n    device,\n    format: swapChainFormat\n  })\n\n  const bindGroupLayout = device.createBindGroupLayout({\n    entries: [\n      {\n        /* use for sampler */\n        binding: 0,\n        visibility: GPUShaderStage.FRAGMENT,\n        sampler: {\n          type: 'filtering',\n        },\n      },\n      {\n        /* use for texture view */\n        binding: 1,\n        visibility: GPUShaderStage.FRAGMENT,\n        texture: {\n          sampleType: 'float'\n        }\n      }\n    ]\n  })\n  const pipelineLayout = device.createPipelineLayout({\n    bindGroupLayouts: [bindGroupLayout],\n  })\n  \n  // --- create sampler --- //\n  const sampler = device.createSampler({\n    minFilter: \"linear\",\n    magFilter: \"linear\"\n  })\n  // --- end --- //\n\n  const img = document.createElement('img')\n  img.src = 'texture.webp'\n  await img.decode()\n  const imageBitmap = await createImageBitmap(img)\n  // --- create texture --- //\n  const texture = device.createTexture({\n    size: [img.width, img.height], // 256, 256\n    format: \"rgba8unorm\",\n    usage: GPUTextureUsage.SAMPLED | GPUTextureUsage.COPY_DST\n  })\n  // --- end --- //\n\n  device.queue.copyImageBitmapToTexture({\n    imageBitmap: imageBitmap\n  }, {\n    texture: texture\n  }, [img.width, img.height, 1])\n  // --- end --- //\n\n  const vbo = device.createBuffer({\n    size: vbodata.byteLength,\n    usage: GPUBufferUsage.VERTEX,\n    mappedAtCreation: true\n  })\n  new Float32Array(vbo.getMappedRange()).set(vbodata)\n  vbo.unmap()\n\n  const pipeline = device.createRenderPipeline({\n    layout: pipelineLayout,\n    vertex: {\n      module: device.createShaderModule({\n        code: vertexShaderSource\n      }),\n      entryPoint: 'vertex_main',\n      buffers: [{\n        arrayStride: 4 * vbodata.BYTES_PER_ELEMENT,\n        attributes: [{\n          // position\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float32x2'\n        }, {\n          // uv0\n          shaderLocation: 1,\n          offset: 2 * vbodata.BYTES_PER_ELEMENT,\n          format: 'float32x2'\n        }]\n      }]\n    },\n    fragment: {\n      module: device.createShaderModule({\n        code: fragmentShaderSource\n      }),\n      entryPoint: 'frag_main',\n      targets: [\n        {\n          format: swapChainFormat\n        }\n      ]\n    },\n    primitive: {\n      topology: 'triangle-list',\n    },\n  })\n  const uniformBindGroup = device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n      {\n        binding: 0,\n        resource: sampler,\n      },\n      {\n        binding: 1,\n        resource: texture.createView()\n      }\n    ]\n  })\n\n  return function requestNewFrame() {\n    const commandEncoder = device.createCommandEncoder()\n    const textureView = swapChain.getCurrentTexture().createView()\n    const renderPassDescriptor = {\n      colorAttachments: [\n        {\n          view: textureView,\n          loadValue: {\n            r: 0.0,\n            g: 0.0,\n            b: 0.0,\n            a: 1.0\n          }\n        }\n      ]\n    }\n\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor)\n    passEncoder.setPipeline(pipeline)\n    passEncoder.setBindGroup(0, uniformBindGroup)\n    passEncoder.setVertexBuffer(0, vbo)\n    passEncoder.draw(3, 1, 0, 0)\n    passEncoder.endPass()\n    \n    device.queue.submit([commandEncoder.finish()])\n\n    // requestAnimationFrame(requestNewFrame)\n  }\n}\n\nrender().then(requestNewFrame => requestNewFrame())\n",n=new Float32Array([-1,-1,0,1,0,1,.5,0,1,-1,1,1]),t=async e=>{const t=await navigator.gpu.requestAdapter(),a=await t.requestDevice(),r="bgra8unorm",i=e.getContext("gpupresent").configureSwapChain({device:a,format:r}),o=a.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}}]}),s=a.createPipelineLayout({bindGroupLayouts:[o]}),u=a.createSampler({minFilter:"linear",magFilter:"linear"}),c=document.createElement("img");c.src="/pages-webgpu/data/texture.webp",await c.decode();const d=await createImageBitmap(c),m=a.createTexture({size:[c.width,c.height],format:"rgba8unorm",usage:GPUTextureUsage.SAMPLED|GPUTextureUsage.COPY_DST});a.queue.copyImageBitmapToTexture({imageBitmap:d},{texture:m},[c.width,c.height,1]);const p=a.createBuffer({size:n.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(p.getMappedRange()).set(n),p.unmap();const g=a.createRenderPipeline({layout:s,vertex:{module:a.createShaderModule({code:"\n"}),entryPoint:"vertex_main",buffers:[{arrayStride:4*n.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:2*n.BYTES_PER_ELEMENT,format:"float32x2"}]}]},fragment:{module:a.createShaderModule({code:"\n"}),entryPoint:"frag_main",targets:[{format:r}]},primitive:{topology:"triangle-list"}}),l=a.createBindGroup({layout:g.getBindGroupLayout(0),entries:[{binding:0,resource:u},{binding:1,resource:m.createView()}]});return function(){const e=a.createCommandEncoder(),n={colorAttachments:[{view:i.getCurrentTexture().createView(),loadValue:{r:0,g:0,b:0,a:1}}]},t=e.beginRenderPass(n);t.setPipeline(g),t.setBindGroup(0,l),t.setVertexBuffer(0,p),t.draw(3,1,0,0),t.endPass(),a.queue.submit([e.finish()])}};export{t as init,e as javascriptCode};
