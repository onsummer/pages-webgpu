const e="[[builtin(position)]] var<out> out_position: vec4<f32>;\n[[location(0)]] var<out> out_color: vec4<f32>;\n[[location(0)]] var<in> in_position_2d: vec2<f32>;\n[[location(1)]] var<in> in_color_rgba: vec4<f32>;\n[[stage(vertex)]]\nfn main() -> void {\n  out_position = vec4<f32>(in_position_2d, 0.0, 1.0);\n  out_color = in_color_rgba;\n  return;\n}\n",n="[[location(0)]] var<out> outColor: vec4<f32>;\n[[location(0)]] var<in> in_color: vec4<f32>;\n[[stage(fragment)]]\nfn main() -> void {\n  outColor = in_color;\n  return;\n}\n",t=`const canvas = document.getElementById('gpuweb')\nconst vbodata = new Float32Array([\n  -0.5, 0.0, 1.0, 0.0, 0.0, 1.0,\n  0.0, 0.5, 0.0, 1.0, 0.0, 1.0,\n  0.5, 0.0, 0.0, 0.0, 1.0, 1.0\n])\n\nconst vertexShaderSource = \`${e}\`\n\nconst fragmentShaderSource = \`${n}\`\n\nasync function render() {\n  const adapter = await navigator.gpu.requestAdapter()\n  const device = await adapter.requestDevice()\n\n  const context = canvas.getContext('gpupresent')\n  const swapChainFormat = "bgra8unorm"\n  const swapChain = context.configureSwapChain({\n    device,\n    format: swapChainFormat\n  })\n\n  const sampleTimes = 4\n\n  const vbo = device.createBuffer({\n    size: vbodata.byteLength,\n    usage: GPUBufferUsage.VERTEX,\n    mappedAtCreation: true\n  })\n  new Float32Array(vbo.getMappedRange()).set(vbodata)\n  vbo.unmap()\n\n  const pipeline = device.createRenderPipeline({\n    vertex: {\n      module: device.createShaderModule({\n        code: vertexShaderSource\n      }),\n      entryPoint: 'main',\n      buffers: [{\n        arrayStride: 6 * vbodata.BYTES_PER_ELEMENT,\n        attributes: [{\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float32x2'\n        }, {\n          shaderLocation: 1,\n          offset: 2 * vbodata.BYTES_PER_ELEMENT,\n          format: 'float32x4'\n        }]\n      }]\n    },\n    fragment: {\n      module: device.createShaderModule({\n        code: fragmentShaderSource\n      }),\n      entryPoint: 'main',\n      targets: [\n        {\n          format: swapChainFormat\n        }\n      ]\n    },\n    primitive: {\n      topology: 'triangle-list',\n    },\n    multisample: {\n      count: sampleTimes\n    }\n  })\n\n  const texture = device.createTexture({\n    size: {\n      width: canvas.width,\n      height: canvas.height,\n    },\n    sampleCount: sampleTimes,\n    format: swapChainFormat,\n    usage: GPUTextureUsage.RENDER_ATTACHMENT,\n  })\n  const msaa_textureView = texture.createView()\n\n  const commandEncoder = device.createCommandEncoder()\n  const textureView = swapChain.getCurrentTexture().createView()\n  const renderPassDescriptor = {\n    colorAttachments: [\n      {\n        view: msaa_textureView,\n        resolveTarget: textureView,\n        loadValue: {\n          r: 0.0,\n          g: 0.0,\n          b: 0.0,\n          a: 1.0\n        }\n      }\n    ]\n  }\n\n  const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor)\n  passEncoder.setPipeline(pipeline)\n  passEncoder.setVertexBuffer(0, vbo)\n  passEncoder.draw(3, 1, 0, 0)\n  passEncoder.endPass()\n\n  device.queue.submit([commandEncoder.finish()])\n}\n\nrender()\n`,a=new Float32Array([-.5,0,1,0,0,1,0,.5,0,1,0,1,.5,0,0,0,1,1]);async function r(t){const r=await navigator.gpu.requestAdapter(),o=await r.requestDevice(),i="bgra8unorm",s=t.getContext("gpupresent").configureSwapChain({device:o,format:i}),c=o.createBuffer({size:a.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(c.getMappedRange()).set(a),c.unmap();const d=o.createRenderPipeline({vertex:{module:o.createShaderModule({code:e}),entryPoint:"main",buffers:[{arrayStride:6*a.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:2*a.BYTES_PER_ELEMENT,format:"float32x4"}]}]},fragment:{module:o.createShaderModule({code:n}),entryPoint:"main",targets:[{format:i}]},primitive:{topology:"triangle-list"},multisample:{count:4}}),u=o.createTexture({size:{width:t.width,height:t.height},sampleCount:4,format:i,usage:GPUTextureUsage.RENDER_ATTACHMENT}).createView(),m=o.createCommandEncoder(),p={colorAttachments:[{view:u,resolveTarget:s.getCurrentTexture().createView(),loadValue:{r:0,g:0,b:0,a:1}}]},l=m.beginRenderPass(p);l.setPipeline(d),l.setVertexBuffer(0,c),l.draw(3,1,0,0),l.endPass(),o.queue.submit([m.finish()])}export{r as init,t as javascriptCode};
