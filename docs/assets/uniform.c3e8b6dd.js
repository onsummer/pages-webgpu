const e="[[builtin(position)]] var<out> out_position: vec4<f32>;\n[[location(0)]] var<in> in_position_2d: vec2<f32>;\n\n[[stage(vertex)]]\nfn main() -> void {\n  out_position = vec4<f32>(in_position_2d, 0.0, 1.0);\n  return;\n}\n",n="[[block]] struct Uniforms {\n  uniform_color: vec4<f32>;\n};\n[[binding(0), group(0)]] var<uniform> uniforms: Uniforms;\n[[location(0)]] var<out> outColor: vec4<f32>;\n\n[[stage(fragment)]]\nfn main() -> void {\n  outColor = uniforms.uniform_color; // <- 从 uniform 里取一个颜色值\n  return;\n}\n",r=`const canvas = document.getElementById('gpuweb')\nconst vbodata = new Float32Array([\n  -0.5, 0.0, \n  0.0, 0.5,\n  0.5, 0.0,\n])\n\nconst vertexShaderSource = \`${e}\`\n\nconst fragmentShaderSource = \`${n}\`\n\nasync function render() {\n  if (!navigator.gpu) {\n    alert('你的浏览器不支持 WebGPU 或未开启 WebGPU 支持')\n    return\n  }\n  const adapter = await navigator.gpu.requestAdapter()\n  const device = await adapter.requestDevice()\n\n  const context = canvas.getContext('gpupresent')\n  const swapChainFormat = 'bgra8unorm'\n  const swapChain = context.configureSwapChain({\n    device,\n    format: swapChainFormat\n  })\n\n  const vbo = device.createBuffer({\n    size: vbodata.byteLength,\n    usage: GPUBufferUsage.VERTEX,\n    mappedAtCreation: true\n  })\n  new Float32Array(vbo.getMappedRange()).set(vbodata)\n  vbo.unmap()\n\n  const bindGroupLayout = device.createBindGroupLayout({\n    entries: [\n      {\n        /* use for matrix */\n        binding: 0,\n        visibility: GPUShaderStage.FRAGMENT,\n        buffer: {\n          type: 'uniform'\n        }\n      }\n    ]\n  })\n  const pipelineLayout = device.createPipelineLayout({\n    bindGroupLayouts: [bindGroupLayout]\n  })\n\n  const pipeline = device.createRenderPipeline({\n    layout: pipelineLayout,\n    vertex: {\n      module: device.createShaderModule({\n        code: vertexShaderSource\n      }),\n      entryPoint: 'main',\n      buffers: [{\n        arrayStride: 2 * vbodata.BYTES_PER_ELEMENT,\n        attributes: [{\n          shaderLocation: 0,\n          offset: 0,\n          format: 'float32x2'\n        }]\n      }]\n    },\n    fragment: {\n      module: device.createShaderModule({\n        code: fragmentShaderSource\n      }),\n      entryPoint: 'main',\n      targets: [\n        {\n          format: swapChainFormat\n        }\n      ]\n    },\n    primitive: {\n      topology: 'triangle-list',\n    },\n  })\n\n  /* create uniform buffer */\n  const uniformBufferSize = 4 * 4 // vec4<f32>\n  const uniformBuffer = device.createBuffer({\n    size: uniformBufferSize,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  })\n  const uniformBindGroup = device.createBindGroup({\n    layout: bindGroupLayout, // <- 直接传递 绑定组布局对象 也可以\n    entries: [\n      {\n        binding: 0,\n        resource: {\n          buffer: uniformBuffer\n        }\n      }\n    ]\n  })\n  const uniformColor = new Float32Array([0.0, 0.5, 0.0, 1.0])\n  device.queue.writeBuffer(uniformBuffer, 0, uniformColor.buffer, uniformColor.byteOffset, uniformColor.byteLength)\n\n  const commandEncoder = device.createCommandEncoder()\n  const textureView = swapChain.getCurrentTexture().createView()\n  const renderPassDescriptor = {\n    colorAttachments: [\n      {\n        view: textureView,\n        loadValue: {\n          r: 0.0,\n          g: 0.0,\n          b: 0.0,\n          a: 1.0\n        }\n      }\n    ]\n  }\n\n  const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor)\n  passEncoder.setPipeline(pipeline)\n  passEncoder.setBindGroup(0, uniformBindGroup)\n  passEncoder.setVertexBuffer(0, vbo)\n  passEncoder.draw(3, 1, 0, 0)\n  passEncoder.endPass()\n\n  device.queue.submit([commandEncoder.finish()])\n}\n\nrender()\n`,t=new Float32Array([-.5,0,0,.5,.5,0]),o=async r=>{const o=await navigator.gpu.requestAdapter(),a=await o.requestDevice(),i="bgra8unorm",u=r.getContext("gpupresent").configureSwapChain({device:a,format:i}),s=a.createBuffer({size:t.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(s.getMappedRange()).set(t),s.unmap();const c=a.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),f=a.createPipelineLayout({bindGroupLayouts:[c]}),d=a.createRenderPipeline({layout:f,vertex:{module:a.createShaderModule({code:e}),entryPoint:"main",buffers:[{arrayStride:2*t.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]}]},fragment:{module:a.createShaderModule({code:n}),entryPoint:"main",targets:[{format:i}]},primitive:{topology:"triangle-list"}}),p=a.createBuffer({size:16,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),m=a.createBindGroup({layout:c,entries:[{binding:0,resource:{buffer:p}}]}),g=new Float32Array([0,.5,0,1]);a.queue.writeBuffer(p,0,g.buffer,g.byteOffset,g.byteLength);const l=a.createCommandEncoder(),v={colorAttachments:[{view:u.getCurrentTexture().createView(),loadValue:{r:0,g:0,b:0,a:1}}]},b=l.beginRenderPass(v);b.setPipeline(d),b.setBindGroup(0,m),b.setVertexBuffer(0,s),b.draw(3,1,0,0),b.endPass(),a.queue.submit([l.finish()])};export{o as init,r as javascriptCode};
